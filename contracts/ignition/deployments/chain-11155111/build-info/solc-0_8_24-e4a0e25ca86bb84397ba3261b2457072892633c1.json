{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-e4a0e25ca86bb84397ba3261b2457072892633c1",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/renderers/ToneRenderer.sol": "project/contracts/renderers/ToneRenderer.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 100000
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.0.2/",
        "project/:scripty.sol/=npm/scripty.sol@2.1.1/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.0.2/utils/Base64.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.2) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.0.2/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/core/ScriptyCore.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n//░░░░░░░░░░░░░░░░░░░░░░    CORE    ░░░░░░░░░░░░░░░░░░░░░//\n///////////////////////////////////////////////////////////\n\nimport {HTMLRequest, HTMLTagType, HTMLTag} from \"./ScriptyStructs.sol\";\nimport {DynamicBuffer} from \"./../utils/DynamicBuffer.sol\";\nimport {IScriptyContractStorage} from \"./../interfaces/IScriptyContractStorage.sol\";\n\ncontract ScriptyCore {\n    using DynamicBuffer for bytes;\n\n    // =============================================================\n    //                        TAG CONSTANTS\n    // =============================================================\n\n    // data:text/html;base64,\n    // raw\n    // 22 bytes\n    bytes public constant DATA_HTML_BASE64_URI_RAW = \"data:text/html;base64,\";\n    // url encoded\n    // 21 bytes\n    bytes public constant DATA_HTML_URL_SAFE = \"data%3Atext%2Fhtml%2C\";\n\n    // <html>,\n    // raw\n    // 6 bytes\n    bytes public constant HTML_OPEN_RAW = \"<html>\";\n    // url encoded\n    // 10 bytes\n    bytes public constant HTML_OPEN_URL_SAFE = \"%3Chtml%3E\";\n\n    // <head>,\n    // raw\n    // 6 bytes\n    bytes public constant HEAD_OPEN_RAW = \"<head>\";\n    // url encoded\n    // 10 bytes\n    bytes public constant HEAD_OPEN_URL_SAFE = \"%3Chead%3E\";\n\n    // </head>,\n    // raw\n    // 7 bytes\n    bytes public constant HEAD_CLOSE_RAW = \"</head>\";\n    // url encoded\n    // 13 bytes\n    bytes public constant HEAD_CLOSE_URL_SAFE = \"%3C%2Fhead%3E\";\n\n    // <body>\n    // 6 bytes\n    bytes public constant BODY_OPEN_RAW = \"<body>\";\n    // url encoded\n    // 10 bytes\n    bytes public constant BODY_OPEN_URL_SAFE = \"%3Cbody%3E\";\n\n    // </body></html>\n    // 14 bytes\n    bytes public constant HTML_BODY_CLOSED_RAW = \"</body></html>\";\n    // 26 bytes\n    bytes public constant HTML_BODY_CLOSED_URL_SAFE =\n        \"%3C%2Fbody%3E%3C%2Fhtml%3E\";\n\n    // [RAW]\n    // HTML_OPEN + HEAD_OPEN + HEAD_CLOSE + BODY_OPEN + HTML_BODY_CLOSED\n    uint256 public constant URLS_RAW_BYTES = 39;\n\n    // [URL_SAFE]\n    // DATA_HTML_URL_SAFE + HTML_OPEN + HEAD_OPEN + HEAD_CLOSE + BODY_OPEN + HTML_BODY_CLOSED\n    uint256 public constant URLS_SAFE_BYTES = 90;\n\n    // [RAW]\n    // HTML_OPEN + HTML_CLOSE\n    uint256 public constant HTML_RAW_BYTES = 13;\n\n    // [RAW]\n    // HEAD_OPEN + HEAD_CLOSE\n    uint256 public constant HEAD_RAW_BYTES = 13;\n\n    // [RAW]\n    // BODY_OPEN + BODY_CLOSE\n    uint256 public constant BODY_RAW_BYTES = 13;\n\n    // All raw\n    // HTML_RAW_BYTES + HEAD_RAW_BYTES + BODY_RAW_BYTES\n    uint256 public constant RAW_BYTES = 39;\n\n    // [URL_SAFE]\n    // HTML_OPEN + HTML_CLOSE\n    uint256 public constant HTML_URL_SAFE_BYTES = 23;\n\n    // [URL_SAFE]\n    // HEAD_OPEN + HEAD_CLOSE\n    uint256 public constant HEAD_URL_SAFE_BYTES = 23;\n\n    // [URL_SAFE]\n    // BODY_OPEN + BODY_CLOSE\n    uint256 public constant BODY_SAFE_BYTES = 23;\n\n    // All url safe\n    // HTML_URL_SAFE_BYTES + HEAD_URL_SAFE_BYTES + BODY_URL_SAFE_BYTES\n    // %3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\n    uint256 public constant URL_SAFE_BYTES = 69;\n\n    // data:text/html;base64,\n    uint256 public constant HTML_BASE64_DATA_URI_BYTES = 22;\n\n    // =============================================================\n    //                    TAG OPEN CLOSE TEMPLATES\n    // =============================================================\n\n    /**\n     * @notice Grab tag open and close depending on tag type\n     * @dev\n     *      tagType: 0/HTMLTagType.useTagOpenAndClose or any other:\n     *          [tagOpen][CONTENT][tagClose]\n     *\n     *      tagType: 1/HTMLTagType.script:\n     *          <script>[SCRIPT]</script>\n     *\n     *      tagType: 2/HTMLTagType.scriptBase64DataURI:\n     *          <script src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      tagType: 3/HTMLTagType.scriptGZIPBase64DataURI:\n     *          <script type=\"text/javascript+gzip\" src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      tagType: 4/HTMLTagType.scriptPNGBase64DataURI\n     *          <script type=\"text/javascript+png\" name=\"[NAME]\" src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      [IMPORTANT NOTE]: The tags `text/javascript+gzip` and `text/javascript+png` are used to identify scripts\n     *      during decompression\n     *\n     * @param htmlTag - HTMLTag data for code\n     * @return (tagOpen, tagClose) - Tag open and close as a tuple\n     */\n    function tagOpenCloseForHTMLTag(\n        HTMLTag memory htmlTag\n    ) public pure returns (bytes memory, bytes memory) {\n        if (htmlTag.tagType == HTMLTagType.script) {\n            return (\"<script>\", \"</script>\");\n        } else if (htmlTag.tagType == HTMLTagType.scriptBase64DataURI) {\n            return ('<script src=\"data:text/javascript;base64,', '\"></script>');\n        } else if (htmlTag.tagType == HTMLTagType.scriptGZIPBase64DataURI) {\n            return (\n                '<script type=\"text/javascript+gzip\" src=\"data:text/javascript;base64,',\n                '\"></script>'\n            );\n        } else if (htmlTag.tagType == HTMLTagType.scriptPNGBase64DataURI) {\n            return (\n                '<script type=\"text/javascript+png\" src=\"data:text/javascript;base64,',\n                '\"></script>'\n            );\n        }\n        return (htmlTag.tagOpen, htmlTag.tagClose);\n    }\n\n    /**\n     * @notice Grab URL safe tag open and close depending on tag type\n     * @dev\n     *      tagType: 0/HTMLTagType.useTagOpenAndClose or any other:\n     *          [tagOpen][scriptContent or scriptFromContract][tagClose]\n     *\n     *      tagType: 1/HTMLTagType.script:\n     *      tagType: 2/HTMLTagType.scriptBase64DataURI:\n     *          <script src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      tagType: 3/HTMLTagType.scriptGZIPBase64DataURI:\n     *          <script type=\"text/javascript+gzip\" src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      tagType: 4/HTMLTagType.scriptPNGBase64DataURI\n     *          <script type=\"text/javascript+png\" name=\"[NAME]\" src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      [IMPORTANT NOTE]: The tags `text/javascript+gzip` and `text/javascript+png` are used to identify scripts\n     *      during decompression\n     *\n     * @param htmlTag - HTMLTag data for code\n     * @return (tagOpen, tagClose) - Tag open and close as a tuple\n     */\n    function tagOpenCloseForHTMLTagURLSafe(\n        HTMLTag memory htmlTag\n    ) public pure returns (bytes memory, bytes memory) {\n        if (\n            htmlTag.tagType == HTMLTagType.script ||\n            htmlTag.tagType == HTMLTagType.scriptBase64DataURI\n        ) {\n            // <script src=\"data:text/javascript;base64,\n            // \"></script>\n            return (\n                \"%253Cscript%2520src%253D%2522data%253Atext%252Fjavascript%253Bbase64%252C\",\n                \"%2522%253E%253C%252Fscript%253E\"\n            );\n        } else if (htmlTag.tagType == HTMLTagType.scriptGZIPBase64DataURI) {\n            // <script type=\"text/javascript+gzip\" src=\"data:text/javascript;base64,\n            // \"></script>\n            return (\n                \"%253Cscript%2520type%253D%2522text%252Fjavascript%252Bgzip%2522%2520src%253D%2522data%253Atext%252Fjavascript%253Bbase64%252C\",\n                \"%2522%253E%253C%252Fscript%253E\"\n            );\n        } else if (htmlTag.tagType == HTMLTagType.scriptPNGBase64DataURI) {\n            // <script type=\"text/javascript+png\" src=\"data:text/javascript;base64,\n            // \"></script>\n            return (\n                \"%253Cscript%2520type%253D%2522text%252Fjavascript%252Bpng%2522%2520src%253D%2522data%253Atext%252Fjavascript%253Bbase64%252C\",\n                \"%2522%253E%253C%252Fscript%253E\"\n            );\n        }\n        return (htmlTag.tagOpen, htmlTag.tagClose);\n    }\n\n    // =============================================================\n    //                      TAG CONTENT FETCHER\n    // =============================================================\n\n    /**\n     * @notice Grabs requested tag content from storage\n     * @dev\n     *      If given HTMLTag contains non empty contractAddress\n     *      this method will fetch the content from given storage\n     *      contract. Otherwise, it will return the tagContent\n     *      from the given htmlTag.\n     *\n     * @param htmlTag - HTMLTag\n     */\n    function fetchTagContent(\n        HTMLTag memory htmlTag\n    ) public view returns (bytes memory) {\n        if (htmlTag.contractAddress != address(0)) {\n            return\n                IScriptyContractStorage(htmlTag.contractAddress).getContent(\n                    htmlTag.name,\n                    htmlTag.contractData\n                );\n        }\n        return htmlTag.tagContent;\n    }\n\n    // =============================================================\n    //                        SIZE OPERATIONS\n    // =============================================================\n\n    /**\n     * @notice Calculate the buffer size post base64 encoding\n     * @param value - Starting buffer size\n     * @return Final buffer size as uint256\n     */\n    function sizeForBase64Encoding(\n        uint256 value\n    ) public pure returns (uint256) {\n        unchecked {\n            return 4 * ((value + 2) / 3);\n        }\n    }\n\n    /**\n     * @notice Adds the required tag open/close and calculates buffer size of tags\n     * @dev Effectively multiple functions bundled into one as this saves gas\n     * @param htmlTags - Array of HTMLTag\n     * @param isURLSafe - Bool to handle tag content/open/close encoding\n     * @return Total buffersize of updated HTMLTags\n     */\n    function _enrichHTMLTags(\n        HTMLTag[] memory htmlTags,\n        bool isURLSafe\n    ) internal view returns (uint256) {\n        if (htmlTags.length == 0) {\n            return 0;\n        }\n\n        bytes memory tagOpen;\n        bytes memory tagClose;\n        bytes memory tagContent;\n\n        uint256 totalSize;\n        uint256 length = htmlTags.length;\n        uint256 i;\n\n        unchecked {\n            do {\n                tagContent = fetchTagContent(htmlTags[i]);\n                htmlTags[i].tagContent = tagContent;\n\n                if (isURLSafe && htmlTags[i].tagType == HTMLTagType.script) {\n                    totalSize += sizeForBase64Encoding(tagContent.length);\n                } else {\n                    totalSize += tagContent.length;\n                }\n\n                if (isURLSafe) {\n                    (tagOpen, tagClose) = tagOpenCloseForHTMLTagURLSafe(\n                        htmlTags[i]\n                    );\n                } else {\n                    (tagOpen, tagClose) = tagOpenCloseForHTMLTag(htmlTags[i]);\n                }\n\n                htmlTags[i].tagOpen = tagOpen;\n                htmlTags[i].tagClose = tagClose;\n\n                totalSize += tagOpen.length;\n                totalSize += tagClose.length;\n            } while (++i < length);\n        }\n        return totalSize;\n    }\n\n    // =============================================================\n    //                     HTML CONCATENATION\n    // =============================================================\n\n    /**\n     * @notice Append tags to the html buffer for tags\n     * @param htmlFile - bytes buffer\n     * @param htmlTags - Tags being added to buffer\n     * @param base64EncodeTagContent - Bool to handle tag content encoding\n     */\n    function _appendHTMLTags(\n        bytes memory htmlFile,\n        HTMLTag[] memory htmlTags,\n        bool base64EncodeTagContent\n    ) internal pure {\n        uint256 i;\n        unchecked {\n            do {\n                _appendHTMLTag(htmlFile, htmlTags[i], base64EncodeTagContent);\n            } while (++i < htmlTags.length);\n        }\n    }\n\n    /**\n     * @notice Append tag to the html buffer\n     * @param htmlFile - bytes buffer\n     * @param htmlTag - Request being added to buffer\n     * @param base64EncodeTagContent - Bool to handle tag content encoding\n     */\n    function _appendHTMLTag(\n        bytes memory htmlFile,\n        HTMLTag memory htmlTag,\n        bool base64EncodeTagContent\n    ) internal pure {\n        htmlFile.appendSafe(htmlTag.tagOpen);\n        if (base64EncodeTagContent) {\n            htmlFile.appendSafeBase64(htmlTag.tagContent, false, false);\n        } else {\n            htmlFile.appendSafe(htmlTag.tagContent);\n        }\n        htmlFile.appendSafe(htmlTag.tagClose);\n    }\n}\n"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/core/ScriptyStructs.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n//░░░░░░░░░░░░░░░░░░░    REQUESTS    ░░░░░░░░░░░░░░░░░░░░//\n///////////////////////////////////////////////////////////\n\nstruct HTMLRequest {\n    HTMLTag[] headTags;\n    HTMLTag[] bodyTags;\n}\n\nenum HTMLTagType {\n    useTagOpenAndClose,\n    script,\n    scriptBase64DataURI,\n    scriptGZIPBase64DataURI,\n    scriptPNGBase64DataURI\n}\n\nstruct HTMLTag {\n    string name;\n    address contractAddress;\n    bytes contractData;\n    HTMLTagType tagType;\n    bytes tagOpen;\n    bytes tagClose;\n    bytes tagContent;\n}"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/interfaces/IScriptyBuilderV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n\n/**\n  @title A generic HTML builder that fetches and assembles given JS requests.\n  @author @0xthedude\n  @author @xtremetom\n\n  Special thanks to @cxkoda and @frolic\n*/\n\nimport \"./IScriptyHTML.sol\";\nimport \"./IScriptyHTMLURLSafe.sol\";\n\ninterface IScriptyBuilderV2 is IScriptyHTML, IScriptyHTMLURLSafe {}\n"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/interfaces/IScriptyContractStorage.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n\ninterface IScriptyContractStorage {\n    // =============================================================\n    //                            GETTERS\n    // =============================================================\n\n    /**\n     * @notice Get the full content\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\n     * @param data - Arbitrary data to be passed to storage\n     * @return script - Full script from merged chunks\n     */\n    function getContent(string calldata name, bytes memory data)\n        external\n        view\n        returns (bytes memory script);\n}\n"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/interfaces/IScriptyHTML.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n\nimport {HTMLRequest, HTMLTagType, HTMLTag} from \"./../core/ScriptyCore.sol\";\n\ninterface IScriptyHTML {\n    // =============================================================\n    //                      RAW HTML GETTERS\n    // =============================================================\n\n    /**\n     * @notice  Get HTML with requested head tags and body tags\n     * @dev Your HTML is returned in the following format:\n     *      <html>\n     *          <head>\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\n     *              ...\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\n     *          </head>\n     *          <body>\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\n     *              ...\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\n     *          </body>\n     *      </html>\n     * @param htmlRequest - HTMLRequest\n     * @return Full HTML with head and body tags\n     */\n    function getHTML(\n        HTMLRequest memory htmlRequest\n    ) external view returns (bytes memory);\n\n    // =============================================================\n    //                      ENCODED HTML GETTERS\n    // =============================================================\n\n    /**\n     * @notice Get {getHTML} and base64 encode it\n     * @param htmlRequest - HTMLRequest\n     * @return Full HTML with head and script tags, base64 encoded\n     */\n    function getEncodedHTML(\n        HTMLRequest memory htmlRequest\n    ) external view returns (bytes memory);\n\n    // =============================================================\n    //                      STRING UTILITIES\n    // =============================================================\n\n    /**\n     * @notice Convert {getHTML} output to a string\n     * @param htmlRequest - HTMLRequest\n     * @return {getHTMLWrapped} as a string\n     */\n    function getHTMLString(\n        HTMLRequest memory htmlRequest\n    ) external view returns (string memory);\n\n    /**\n     * @notice Convert {getEncodedHTML} output to a string\n     * @param htmlRequest - HTMLRequest\n     * @return {getEncodedHTML} as a string\n     */\n    function getEncodedHTMLString(\n        HTMLRequest memory htmlRequest\n    ) external view returns (string memory);\n}\n"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/interfaces/IScriptyHTMLURLSafe.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n///////////////////////////////////////////////////////////\n// ░██████╗░█████╗░██████╗░██╗██████╗░████████╗██╗░░░██╗ //\n// ██╔════╝██╔══██╗██╔══██╗██║██╔══██╗╚══██╔══╝╚██╗░██╔╝ //\n// ╚█████╗░██║░░╚═╝██████╔╝██║██████╔╝░░░██║░░░░╚████╔╝░ //\n// ░╚═══██╗██║░░██╗██╔══██╗██║██╔═══╝░░░░██║░░░░░╚██╔╝░░ //\n// ██████╔╝╚█████╔╝██║░░██║██║██║░░░░░░░░██║░░░░░░██║░░░ //\n// ╚═════╝░░╚════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░░░░╚═╝░░░░░░╚═╝░░░ //\n///////////////////////////////////////////////////////////\n\nimport {HTMLRequest, HTMLTagType, HTMLTag} from \"./../core/ScriptyCore.sol\";\n\ninterface IScriptyHTMLURLSafe {\n    // =============================================================\n    //                      RAW HTML GETTERS\n    // =============================================================\n\n    /**\n     * @notice  Get URL safe HTML with requested head tags and body tags\n     * @dev Any tags with tagType = 1/script are converted to base64 and wrapped\n     *      with <script src=\"data:text/javascript;base64,[SCRIPT]\"></script>\n     *\n     *      [WARNING]: Large non-base64 libraries that need base64 encoding\n     *      carry a high risk of causing a gas out. Highly advised the use\n     *      of base64 encoded scripts where possible\n     *\n     *      Your HTML is returned in the following format:\n     *\n     *      <html>\n     *          <head>\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\n     *              ...\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\n     *          </head>\n     *          <body>\n     *              [tagOpen[0]][contractRequest[0] | tagContent[0]][tagClose[0]]\n     *              [tagOpen[1]][contractRequest[0] | tagContent[1]][tagClose[1]]\n     *              ...\n     *              [tagOpen[n]][contractRequest[0] | tagContent[n]][tagClose[n]]\n     *          </body>\n     *      </html>\n     * @param htmlRequest - HTMLRequest\n     * @return Full HTML with head and body tags\n     */\n    function getHTMLURLSafe(\n        HTMLRequest memory htmlRequest\n    ) external view returns (bytes memory);\n\n    // =============================================================\n    //                      STRING UTILITIES\n    // =============================================================\n\n    /**\n     * @notice Convert {getHTMLURLSafe} output to a string\n     * @param htmlRequest - HTMLRequest\n     * @return {getHTMLURLSafe} as a string\n     */\n    function getHTMLURLSafeString(\n        HTMLRequest memory htmlRequest\n    ) external view returns (string memory);\n}\n"
      },
      "npm/scripty.sol@2.1.1/contracts/scripty/utils/DynamicBuffer.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\n\npragma solidity ^0.8.22;\n\n/// @title DynamicBuffer\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\n/// @notice This library is used to allocate a big amount of container memory\n//          which will be subsequently filled without needing to reallocate\n///         memory.\n/// @dev First, allocate memory.\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\n///      bounds checking is required.\nlibrary DynamicBuffer {\n    /// @notice Allocates container space for the DynamicBuffer\n    /// @param capacity_ The intended max amount of bytes in the buffer\n    /// @return buffer The memory location of the buffer\n    /// @dev Allocates `capacity_ + 0x60` bytes of space\n    ///      The buffer array starts at the first container data position,\n    ///      (i.e. `buffer = container + 0x20`)\n    function allocate(uint256 capacity_)\n        internal\n        pure\n        returns (bytes memory buffer)\n    {\n        assembly {\n            // Get next-free memory address\n            let container := mload(0x40)\n\n            // Allocate memory by setting a new next-free address\n            {\n                // Add 2 x 32 bytes in size for the two length fields\n                // Add 32 bytes safety space for 32B chunked copy\n                let size := add(capacity_, 0x60)\n                let newNextFree := add(container, size)\n                mstore(0x40, newNextFree)\n            }\n\n            // Set the correct container length\n            {\n                let length := add(capacity_, 0x40)\n                mstore(container, length)\n            }\n\n            // The buffer starts at idx 1 in the container (0 is length)\n            buffer := add(container, 0x20)\n\n            // Init content with length 0\n            mstore(buffer, 0)\n        }\n\n        return buffer;\n    }\n\n    /// @notice Appends data to buffer, and update buffer length\n    /// @param buffer the buffer to append the data to\n    /// @param data the data to append\n    /// @dev Does not perform out-of-bound checks (container capacity)\n    ///      for efficiency.\n    function appendUnchecked(bytes memory buffer, bytes memory data)\n        internal\n        pure\n    {\n        assembly {\n            let length := mload(data)\n            for {\n                data := add(data, 0x20)\n                let dataEnd := add(data, length)\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\n            } lt(data, dataEnd) {\n                data := add(data, 0x20)\n                copyTo := add(copyTo, 0x20)\n            } {\n                // Copy 32B chunks from data to buffer.\n                // This may read over data array boundaries and copy invalid\n                // bytes, which doesn't matter in the end since we will\n                // later set the correct buffer length, and have allocated an\n                // additional word to avoid buffer overflow.\n                mstore(copyTo, mload(data))\n            }\n\n            // Update buffer length\n            mstore(buffer, add(mload(buffer), length))\n        }\n    }\n\n    /// @notice Appends data to buffer, and update buffer length\n    /// @param buffer the buffer to append the data to\n    /// @param data the data to append\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\n        checkOverflow(buffer, data.length);\n        appendUnchecked(buffer, data);\n    }\n\n    /// @notice Appends data encoded as Base64 to buffer.\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.\n    function appendSafeBase64(\n        bytes memory buffer,\n        bytes memory data,\n        bool fileSafe,\n        bool noPadding\n    ) internal pure {\n        uint256 dataLength = data.length;\n\n        if (data.length == 0) {\n            return;\n        }\n\n        uint256 encodedLength;\n        uint256 r;\n        assembly {\n            // For each 3 bytes block, we will have 4 bytes in the base64\n            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.\n            // The `shl(2, ...)` is equivalent to multiplying by 4.\n            encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n            r := mod(dataLength, 3)\n            if noPadding {\n                // if r == 0 => no modification\n                // if r == 1 => encodedLength -= 2\n                // if r == 2 => encodedLength -= 1\n                encodedLength := sub(\n                    encodedLength,\n                    add(iszero(iszero(r)), eq(r, 1))\n                )\n            }\n        }\n\n        checkOverflow(buffer, encodedLength);\n\n        assembly {\n            let nextFree := mload(0x40)\n\n            // Store the table into the scratch space.\n            // Offsetted by -1 byte so that the `mload` will load the character.\n            // We will rewrite the free memory pointer at `0x40` later with\n            // the allocated size.\n            mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n            mstore(\n                0x3f,\n                sub(\n                    \"ghijklmnopqrstuvwxyz0123456789-_\",\n                    // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                    mul(iszero(fileSafe), 0x0230)\n                )\n            )\n\n            // Skip the first slot, which stores the length.\n            let ptr := add(add(buffer, 0x20), mload(buffer))\n            let end := add(data, dataLength)\n\n            // Run over the input, 3 bytes at a time.\n            // prettier-ignore\n            // solhint-disable-next-line no-empty-blocks\n            for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n            if iszero(noPadding) {\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n            }\n\n            mstore(buffer, add(mload(buffer), encodedLength))\n            mstore(0x40, nextFree)\n        }\n    }\n\n    /// @notice Appends data encoded as Base64 to buffer.\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.\n    function appendUncheckedBase64(\n        bytes memory buffer,\n        bytes memory data,\n        bool fileSafe,\n        bool noPadding\n    ) internal pure {\n        uint256 dataLength = data.length;\n\n        if (data.length == 0) {\n            return;\n        }\n\n        uint256 encodedLength;\n        uint256 r;\n        assembly {\n            // For each 3 bytes block, we will have 4 bytes in the base64\n            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.\n            // The `shl(2, ...)` is equivalent to multiplying by 4.\n            encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n            r := mod(dataLength, 3)\n            if noPadding {\n                // if r == 0 => no modification\n                // if r == 1 => encodedLength -= 2\n                // if r == 2 => encodedLength -= 1\n                encodedLength := sub(\n                    encodedLength,\n                    add(iszero(iszero(r)), eq(r, 1))\n                )\n            }\n        }\n\n        assembly {\n            let nextFree := mload(0x40)\n\n            // Store the table into the scratch space.\n            // Offsetted by -1 byte so that the `mload` will load the character.\n            // We will rewrite the free memory pointer at `0x40` later with\n            // the allocated size.\n            mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n            mstore(\n                0x3f,\n                sub(\n                    \"ghijklmnopqrstuvwxyz0123456789-_\",\n                    // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                    mul(iszero(fileSafe), 0x0230)\n                )\n            )\n\n            // Skip the first slot, which stores the length.\n            let ptr := add(add(buffer, 0x20), mload(buffer))\n            let end := add(data, dataLength)\n\n            // Run over the input, 3 bytes at a time.\n            // prettier-ignore\n            // solhint-disable-next-line no-empty-blocks\n            for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n            if iszero(noPadding) {\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n            }\n\n            mstore(buffer, add(mload(buffer), encodedLength))\n            mstore(0x40, nextFree)\n        }\n    }\n\n    /// @notice Returns the capacity of a given buffer.\n    function capacity(bytes memory buffer) internal pure returns (uint256) {\n        uint256 cap;\n        assembly {\n            cap := sub(mload(sub(buffer, 0x20)), 0x40)\n        }\n        return cap;\n    }\n\n    /// @notice Reverts if the buffer will overflow after appending a given\n    /// number of bytes.\n    function checkOverflow(bytes memory buffer, uint256 addedLength)\n        internal\n        pure\n    {\n        uint256 cap = capacity(buffer);\n        uint256 newLength = buffer.length + addedLength;\n        if (cap < newLength) {\n            revert(\"DynamicBuffer: Appending out of bounds.\");\n        }\n    }\n}\n"
      },
      "project/contracts/interfaces/IRenderer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Token } from \"../types/Token.sol\";\n\ninterface IRenderer {\n    function name () external pure returns (string memory);\n\n    function version () external pure returns (uint version);\n\n    function uri (uint tokenId, Token calldata token) external view returns (string memory);\n\n    function imageURI (uint tokenId, Token calldata token) external view returns (string memory);\n\n    function animationURI (uint tokenId, Token calldata token) external view returns (string memory);\n}\n"
      },
      "project/contracts/libraries/ArtifactReader.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Token   } from \"./../types/Token.sol\";\nimport { SSTORE2 } from \"./SSTORE2.sol\";\n\nlibrary ArtifactReader {\n\n    function get (Token memory token) public view returns (bytes memory content) {\n        for (uint8 i = 0; i < token.artifact.length; i++) {\n            content = abi.encodePacked(content, SSTORE2.read(token.artifact[i]));\n        }\n    }\n\n}\n\n"
      },
      "project/contracts/libraries/SSTORE2.sol": {
        "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
      },
      "project/contracts/renderers/ToneRenderer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport { Strings        } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { Base64         } from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport { IScriptyBuilderV2,\n         HTMLRequest,\n         HTMLTagType,\n         HTMLTag        } from \"scripty.sol/contracts/scripty/interfaces/IScriptyBuilderV2.sol\";\nimport { IRenderer      } from \"./../interfaces/IRenderer.sol\";\nimport { ArtifactReader } from \"./../libraries/ArtifactReader.sol\";\nimport { Token          } from \"./../types/Token.sol\";\n\ncontract ToneRenderer is IRenderer {\n    address constant private ethfsFileStorage = 0x8FAA1AAb9DA8c75917C43Fb24fDdb513edDC3245;\n    address constant private scriptyBuilder   = 0xD7587F110E08F4D120A231bA97d3B577A81Df022;\n    address constant private scriptyStorage   = 0xbD11994aABB55Da86DC246EBB17C1Be0af5b7699;\n\n    /// @notice Expose the name of this renderer for easy registration in UIs.\n    function name () external pure returns (string memory) {\n        return \"Tone Renderer\";\n    }\n\n    /// @notice Expose the version of this renderer to identify it in UIs.\n    function version () external pure returns (uint) {\n        return 1;\n    }\n\n    /// @notice Generate the JSON metadata for a given token.\n    ///         We expect the static preview image and Tone.js script\n    //          to both be encoded in the artifact data.\n    function uri (\n        uint tokenId,\n        Token calldata token\n    ) external view returns (string memory) {\n        (string memory image, string memory script) = abi.decode(ArtifactReader.get(token), (string, string));\n\n        bytes memory dataURI = abi.encodePacked(\n            '{',\n                '\"id\": \"', Strings.toString(tokenId), '\",',\n                '\"name\": \"', token.name, '\",',\n                '\"description\": \"', token.description, '\",',\n                '\"image\": \"', image, '\",',\n                '\"animation_url\": \"', generateHtml(token.name, script), '\"',\n            '}'\n        );\n\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(dataURI)\n            )\n        );\n    }\n\n    /// @notice Generate the preview image URI.\n    function imageURI (uint, Token calldata token) external view returns (string memory) {\n        (string memory image,) = abi.decode(ArtifactReader.get(token), (string, string));\n\n        return image;\n    }\n\n    /// @notice Generate the script URI.\n    function scriptURI (uint, Token calldata token) external view returns (string memory) {\n        (, string memory script) = abi.decode(ArtifactReader.get(token), (string, string));\n\n        return string(abi.encodePacked(\"data:text/javascript;base64,\", Base64.encode(bytes(script))));\n    }\n\n    /// @notice Generate the animation URI.\n    function animationURI (uint, Token calldata token) external view returns (string memory) {\n        (, string memory script) = abi.decode(ArtifactReader.get(token), (string, string));\n\n        return generateHtml(token.name, script);\n    }\n\n    /// @dev Generates the HTML for a given token script.\n    function generateHtml (string memory title, string memory script) internal view returns (string memory) {\n        HTMLTag[] memory headTags = new HTMLTag[](2);\n\n        // Name the file\n        headTags[0].tagOpen = \"<title>\";\n        headTags[0].tagContent = bytes(title);\n        headTags[0].tagClose = \"</title>\";\n\n        // Add base styles\n        headTags[1].name = \"fullSizeCanvas.css\";\n        headTags[1].tagOpen = '<link rel=\"stylesheet\" href=\"data:text/css;base64,';\n        headTags[1].tagClose = '\">';\n        headTags[1].contractAddress = ethfsFileStorage;\n\n        // Add Tone.js script\n        HTMLTag[] memory bodyTags = new HTMLTag[](3);\n        bodyTags[0].name = \"Tone.js.gz\";\n        bodyTags[0].tagType = HTMLTagType.scriptGZIPBase64DataURI;\n        bodyTags[0].contractAddress = ethfsFileStorage;\n\n        // Unzip Tone.js script\n        bodyTags[1].name = \"gunzipScripts-0.0.1.js\";\n        bodyTags[1].tagType = HTMLTagType.scriptBase64DataURI;\n        bodyTags[1].contractAddress = ethfsFileStorage;\n\n        // Add our Tone.js script\n        bodyTags[2].tagContent = bytes(script);\n        bodyTags[2].tagType = HTMLTagType.script;\n\n        // Assemble the html\n        HTMLRequest memory htmlRequest;\n        htmlRequest.headTags = headTags;\n        htmlRequest.bodyTags = bodyTags;\n\n        return string(IScriptyBuilderV2(scriptyBuilder).getEncodedHTML(htmlRequest));\n    }\n\n}\n"
      },
      "project/contracts/types/Token.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nstruct Token {\n    string  name;            // token name\n    string  description;    // token description\n    address[] artifact;    // artifact pointers (image/artwork) data\n    uint32  renderer;     // index of renderer contract address\n    uint32  mintedBlock; // creation block height of the token\n    uint64  closeAt;    // timestamp of mint completion\n    uint128 data;      // optional data for renderers\n}\n"
      }
    }
  }
}